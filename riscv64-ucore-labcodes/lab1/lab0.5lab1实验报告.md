

# 实验报告

### 小组成员

朱馨瑞 2212879

冯言旭 2212437

夏雨鍩  2210204

## lab0.5 实验报告

#### 环境启动

首先使用下列三条指令进入调试阶段

```bash
cd ~/OS/riscv64-ucore-labcodes/lab0
```

使用上述命令进入目标项目的文件。

```bash
make debug
```

打开qemu端口，此时该端口等待gdb的连接。

```bash
make gdb
```

将gdb连接到qemu，接下来即可在gdb中进行调试。

#### 调试阶段

```bash
x/10i $pc
```

由指导书可知，QEMU模拟的这款riscv处理器的**复位地址**是0x1000，因此我们首先打开通电后即将执行的十条指令，查看我们的环境是否如此。

```asm
0x1000:      auipc   t0,0x0
0x1004:      addi    a1,t0,32
0x1008:      csrr    a0,mhartid
0x100c:      ld      t0,24(t0)
0x1010:      jr      t0
0x1014:      unimp
0x1016:      unimp
0x1018:      unimp
0x101a:      0x8000
0x101c:      unimp
```

通过查看指令的结果，说明确实是从0x1000开始运行，接下俩开始逐步运行，追踪调试。

```bash
si
```

使用**si**指令逐步运行，发现当执行到0x1010指令处时，有一个跳转到t0的指令，我们使用**info register**指令查看寄存器t0的值，结果如下：

```asm
t0             0x80000000       2147483648
```

发现此时指令跳转到0x80000000 ，即OpenSBI的入口地址，接下来这一bootloader将会开机并把OS加载到内存中去，并最终将权限移交给OS（OS位于0x80200000）。

我们可以通过下面两条指令断点调试查看运行到0x80200000时的情况

```bash
break *0x80200000
continue
```

#### 运行结果

接下来我们完整运行程序，看是否可以得到正确的结果。

```bash
info breakpoints
clear *0x80200000
```

首先使用上述命令查看并删除断点。

然后使用continue继续运行得到结果，结果显示正确。![image-20240928114239383](C:\Users\XYN\AppData\Roaming\Typora\typora-user-images\image-20240928114239383.png)

#### 重要知识点

##### 1. 启动流程与引导程序

- **实验中的知识点**：使用 OpenSBI 作为引导程序加载内核到内存中，并设置内核的入口点。  
- **OS 原理中的知识点**：引导加载程序 (Bootloader) 和操作系统启动。  
- **理解**：
  - **含义**：实验中关注引导程序（OpenSBI）如何加载内核，并设置内核的入口点为 `0x80200000`。操作系统原理中解释引导程序的作用：启动前置任务，加载内核并交出控制权。
  - **差异**：实验更关注 OpenSBI 固件和 RISC-V 的启动实现细节，而 OS 原理讨论的是所有架构中的通用引导概念。

##### 2. 内存布局和链接脚本
- **实验中的知识点**：使用链接脚本设置内核的内存布局，包括 `.text`, `.data`, `.bss` 段。
- **OS 原理中的知识点**：程序的内存布局和段划分。
- **理解**：
  - **含义**：实验中设置了内核的各段（如代码段、数据段、堆栈）的位置，确保内核可以正确加载并执行。操作系统原理则讲解了内存段的划分及其用途。
  - **差异**：实验中实际操作如何通过链接脚本定义段，而原理中是理论描述内存划分和地址空间管理。

##### 3. 特权模式与系统调用
- **实验中的知识点**：通过 `ecall` 指令使用 OpenSBI 的服务在 M-mode 下实现系统调用。
- **OS 原理中的知识点**：特权模式与系统调用机制。
- **理解**：
  - **含义**：实验通过封装 `ecall` 指令与 SBI 接口交互，演示了系统调用的实现。操作系统原理中讨论了不同特权级的角色，M-mode 提供硬件控制，S-mode 管理操作系统，U-mode 执行应用程序。
  - **差异**：实验重点在于使用 RISC-V 架构的 `ecall` 机制进行底层调用，原理探讨系统调用的通用机制。

##### 4. 输入输出管理
- **实验中的知识点**：通过封装 OpenSBI 的 `console_putchar` 接口实现字符输出。
- **OS 原理中的知识点**：I/O 设备管理与驱动程序。
- **理解**：
  - **含义**：实验中封装低级 I/O 操作，创建一个简化的 `cprintf` 函数。操作系统原理解释了 I/O 子系统与硬件的通信机制和驱动程序的实现。
  - **差异**：实验中模拟简单的字符输出，原理涉及完整的 I/O 子系统管理。

#### 未提到的OS重要知识点

##### 1. 进程管理与调度
进程调度是操作系统的核心功能之一，用于管理 CPU 资源分配，确保多进程的高效运行。

##### 2. 虚拟内存与分页机制
虚拟内存通过分页和分段机制，为进程提供一个逻辑地址空间，提升内存使用效率并实现内存隔离。

##### 3. 文件系统管理
文件系统是操作系统用于管理存储设备上的数据存取与管理的子系统，负责文件的创建、删除、读写和权限管理等操作。

##### 4. 进程同步与死锁
进程同步用于协调多个进程对共享资源的访问，避免竞争条件，而死锁则是进程因相互等待资源而无法推进的状态，需要通过设计机制避免。

## lab1 实验报告

### 练习题

#### 练习1：理解内核启动中的程序入口操作

1. **指令 `la sp, bootstacktop`**

 

解释：

\- `la` 是 "Load Address" 的缩写，表示将一个符号（如 `bootstacktop`）的地址加载到寄存器中。

\- `sp` 是栈指针寄存器（Stack Pointer），它保存了当前栈的地址。

\- `bootstacktop` 是在 `.data` 段定义的一个全局符号，通常指向内核栈的顶部。

 

完成的操作：

该指令的目的是将 `bootstacktop` 的地址加载到栈指针寄存器 `sp` 中。这意味着，当前的栈指针将被设置为指向内核栈的顶部（`bootstacktop`）。在现代操作系统中，每个 CPU 核心通常有自己独立的栈，而 `bootstacktop` 通常指向为内核引导过程设置的栈。

 

目的：

内核启动时，需要一个独立的栈来保存临时数据。`la sp, bootstacktop` 指令的目的就是初始化栈指针 `sp`，将其设置为内核的栈空间，这样后续的函数调用和局部变量的使用都可以正常进行，而不会破坏其他内存区域。

 

2. **指令 `tail kern_init`**

 

 解释：

\- `tail` 是一个伪指令，在一些汇编语言中表示一种优化的函数调用方式，特别是在 RISC-V 架构中。这通常用于**尾调用优化**，也就是说它不是通过标准的函数调用过程（如 `call` 或 `jal`），而是用一种高效的方式跳转到另一个函数，并且不会再返回到调用者。

\- `kern_init` 是内核初始化函数的入口，它包含了内核启动后的初步初始化逻辑。

 

完成的操作：

`tail kern_init` 指令将控制权交给 `kern_init` 函数执行，但它不会返回到 `kern_entry`。它相当于一个“跳转并执行”指令（类似于 `jmp` 而不是 `call`），意味着当内核进入 `kern_init` 后，`kern_entry` 的栈帧将被释放，程序不会再回到 `kern_entry`。

 

目的：

内核启动流程中的 `tail kern_init` 用于从 `kern_entry` 跳转到 `kern_init`，并开始执行内核的初始化逻辑。这样做的目的之一是节省栈空间和提高性能，因为 `kern_init` 不需要回到 `kern_entry`，而是直接进入内核的初始化过程。

 

总结：

\- **`la sp, bootstacktop`**：将栈指针 `sp` 设置为指向 `bootstacktop`，目的是初始化内核的栈，使后续的函数调用和局部变量操作可以正常进行。

\- **`tail kern_init`**：高效地跳转到 `kern_init` 函数，开始内核的初始化过程，并且不会返回到调用 `kern_init` 的地方。

#### 练习2：完善中断处理 

```c
case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2    2212879 :  */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            clock_set_next_event();
            ticks++;
            if(ticks%100==0)
            {
                print_ticks();
                num++;
            }
            if(num==10)
            {
                sbi_shutdown();

            }
            break;
```

实验结果如下：

![image-20240929092609494](C:\Users\XYN\AppData\Roaming\Typora\typora-user-images\image-20240929092609494.png)

#### 扩展练习 Challenge1：描述与理解中断流程

**中断处理流程**

 

在ucore操作系统中，中断异常处理的流程大致如下：

 

1. **异常产生**：当处理器检测到异常或中断时，处理器将当前执行的指令暂停，并跳转到特定的中断处理程序入口地址。

 

2. **`SAVE_ALL`**：在进入中断处理程序时，首先保存所有需要保护的寄存器状态，包括通用寄存器和部分CSR，以确保中断处理期间不丢失当前的CPU状态。这个过程通常是通过宏或内联汇编来实现的。

 

3. **`trap`处理函数**：保存完寄存器后，系统会调用对应的中断处理函数，具体执行相应的中断或异常处理逻辑。

 

4. **恢复现场**：处理完成后，恢复之前保存的寄存器，最后执行中断返回指令，将控制权交还给被中断的程序。

 

**`mov a0, sp` 的目的**

 

`mov a0, sp` 这条指令的目的是将当前栈指针 `sp` 的值复制到寄存器 `a0` 中。这样做的目的是为了将栈的地址传递给后续的处理函数，例如中断处理函数 `trap`，以便这些函数能够访问保存的寄存器或栈上的其他数据。

 

 **`SAVE_ALL` 中寄存器保存位置的确定**

 

在 `SAVE_ALL` 宏中，寄存器保存到栈中的位置是根据栈指针 `sp` 逐步递减的位置确定的。保存的顺序通常会在汇编代码中显式定义，以确保恢复时能够准确还原寄存器的状态。每个寄存器的位置通过对 `sp` 的偏移量来确定，并且通常在 `SAVE_ALL` 中会按照一定的顺序（如从最低号寄存器开始）保存寄存器。

 

**是否需要在 `__alltraps` 中保存所有寄存器**

 

在 `__alltraps` 中保存所有寄存器是出于保护被中断程序状态的考虑。对于任何中断，无论是否使用所有寄存器，保存所有通用寄存器的状态可以确保在中断处理程序执行期间不会破坏被中断的程序的状态，这样当中断处理完成后，被中断的程序可以继续正确执行。因此，保存所有寄存器是必要的，除非有特殊优化或确保某些寄存器不会被中断处理程序修改。

####  扩增练习 Challenge2：理解上下文切换机制

在汇编代码中，`csrw sscratch, sp` 是将栈指针寄存器 `sp` 的值保存到 `sscratch` 控制状态寄存器中，而 `csrrw s0, sscratch, x0` 是从 `sscratch` 读取并保存到 `s0`，同时将 `x0`（即零）写入 `sscratch`。这两个指令的目的是在中断或异常处理时保存和恢复栈指针的值。

对于 `SAVE_ALL` 中保存的 `stval` 和 `scause` 等寄存器，它们的保存目的是记录异常或中断的信息。然而，在 `restore_all` 中不需要恢复这些寄存器，因为中断处理完成后，这些寄存器的内容已经失去作用，下一次中断会重新加载新的值，因此无需恢复。保存这些寄存器的目的是供处理中断期间的分析或诊断用，不是为了恢复到原值。

#### 扩展练习Challenge3：完善异常中断

```C
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        case CAUSE_MISALIGNED_FETCH:
            break;
        case CAUSE_FAULT_FETCH:
            break;
        case CAUSE_ILLEGAL_INSTRUCTION:
             // 非法指令异常处理
             /* LAB1 CHALLENGE3   2210204 :  */
            /*(1)输出指令异常类型（ Illegal instruction）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type:Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%lx\n",tf->epc);
            tf->epc += 4;

            break;
        case CAUSE_BREAKPOINT:
            //断点异常处理
            /* LAB1 CHALLLENGE3   2210204 :  */
            /*(1)输出指令异常类型（ breakpoint）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
           cprintf("Exception type: breakpoint\n");
           cprintf("breakpoint caught at 0x%lx\n",tf->epc);
           tf->epc += 2 ;
            break;
```

问题需要处理两种异常，分别是非法指令异常（mret）和断点异常(ebreak)，由于mret为**常规指令**，因此其长度为**4**字节，当发生非法指令异常时，异常处理程序需要将 `tf->epc`（即异常发生时的程序计数器）前进4字节，以跳过当前引发异常的指令。这确保处理完成后程序可以继续从下一条32位指令开始执行。而ebreak是一条**压缩指令**，长度是**2**字节，因此异常处理程序需要将 `tf->epc`（即异常发生时的程序计数器）前进2字节，以跳过当前引发异常的指令。

此外我们在init.c中添加这两条对应的异常指令。

```asm
asm volatile("mret");
asm volatile("ebreak");
```



运行后的结果图如下：

![image-20240929091407282](C:\Users\XYN\AppData\Roaming\Typora\typora-user-images\image-20240929091407282.png)

### 本实验中重要的知识点及其与OS原理的对应关系

#### 1. **中断机制**
   - **实验中的知识点**：
     - 中断的概念和流程：当中断发生时，CPU会暂停当前任务，进入中断处理程序。实验通过插入定时器中断和异常处理来验证中断机制。
     - 实验中实现了定时器中断和异常处理机制，并通过定时器中断来验证时钟中断的正确性。

   - **对应的OS原理**：
     - 中断机制是操作系统中断管理的核心，操作系统通过中断机制来响应外部设备事件或定时器中断，进行多任务调度和处理系统事件。
     - 在OS原理中，中断管理负责调度、进程切换、资源分配等，它使得操作系统能够实时响应各种事件。

   - **含义与差异**：
     - 实验中重点实现了简单的中断处理，如时钟中断、非法指令异常等。而在完整的操作系统中，中断处理机制更复杂，需要管理多个中断源（如设备中断、软件中断）以及确保实时响应，并且需要多任务调度支持。
     - 关系：实验是OS原理中中断管理的基本实现，展示了如何处理中断并返回用户程序。

#### 2. **上下文切换**
   - **实验中的知识点**：
     - 在中断发生时，CPU需要保存当前的执行状态（即寄存器上下文）以便之后恢复。实验中使用汇编宏`SAVE_ALL`和`RESTORE_ALL`来保存和恢复寄存器内容，确保中断处理完成后能够正确返回执行。
     - 上下文包括通用寄存器、异常原因寄存器（`scause`）、异常PC（`sepc`）等。

   - **对应的OS原理**：
     - 在操作系统中，上下文切换不仅用于中断处理，还用于进程切换。当操作系统需要在多个进程间切换时，它必须保存当前进程的状态并加载新进程的状态。
     - 任务调度、信号处理、系统调用等都依赖上下文切换。

   - **含义与差异**：
     - 实验中的上下文切换主要限于处理中断的情境，而OS中的上下文切换涉及更广泛的场景，包括多任务调度、线程切换等。实验中的上下文只处理单个中断，但操作系统中可能涉及多个中断和进程切换的复杂情景。
     - 关系：实验中的上下文切换是操作系统多任务调度的基础，真实的OS会在多个任务或进程之间频繁进行上下文切换。

#### 3. **定时器中断**
   - **实验中的知识点**：
     - 实验通过定时器中断让操作系统每经过一定的时间间隔产生中断，更新系统计时器，并输出“100 ticks”的信息。实验还展示了如何通过定时器中断实现简单的时间管理机制。

   - **对应的OS原理**：
     - 定时器中断是操作系统时间管理和进程调度的核心机制。通过定时器中断，操作系统可以控制时间片调度，确保各个进程能公平地使用CPU。
     - 定时器中断也是多任务操作系统实现时钟管理、系统心跳（heartbeat）的重要手段。

   - **含义与差异**：
     - 实验中的定时器中断是操作系统时钟中断的简化实现，主要用于验证时钟中断的正确性。OS中定时器中断除了管理系统时间外，还用于任务调度、睡眠任务唤醒等复杂的功能。
     - 关系：实验中的定时器中断机制是操作系统时间管理的基本实现，OS原理中这一机制涉及更复杂的调度和时间管理策略。

#### 4. **异常处理**
   - **实验中的知识点**：
     - 实验通过模拟非法指令异常（`CAUSE_ILLEGAL_INSTRUCTION`）和断点异常（`CAUSE_BREAKPOINT`）来演示异常处理的过程。捕捉异常后，实验中输出异常信息，并更新程序计数器（`epc`）以确保程序继续执行。
     - 实验通过 `mret`、`ebreak` 等指令来手动触发异常并进入异常处理流程。

   - **对应的OS原理**：
     - 操作系统中的异常处理包括系统调用、内存访问异常（缺页中断）、非法操作处理等。异常处理是操作系统稳定性的重要保障。
     - 当程序触发异常时，操作系统会处理异常，并决定是否终止进程、记录日志或是将控制权交回用户程序。

   - **含义与差异**：
     - 实验中的异常处理仅限于捕捉异常并简单处理，如输出信息或跳过错误的指令。而操作系统中的异常处理更为复杂，可能涉及系统调用、资源清理和恢复机制。
     - 关系：实验展示了最基础的异常处理流程，而在OS中异常处理与内核的调度、资源管理等机制深度集成。

#### 5. **特权模式与中断委托**
   - **实验中的知识点**：
     - 实验演示了RISC-V的多权限模式（M-mode和S-mode）。在实验中，处理异常和中断需要进入更高权限模式（通常是M-mode）。实验中通过`mret`指令从M-mode返回低权限模式。

   - **对应的OS原理**：
     - 操作系统运行在不同的权限模式下，以保证系统的安全和稳定。通常用户程序在低权限模式（用户态）运行，操作系统核心在高权限模式（内核态）运行。当发生系统调用或中断时，需要从低权限切换到高权限处理，处理完毕后返回低权限。
     - 中断委托是OS原理中的重要机制，通过它可以选择在不同权限模式下处理不同的中断和异常。

   - **含义与差异**：
     - 实验中只展示了从M-mode到S-mode的简单切换，OS中权限模式涉及更复杂的权限管理和内存保护机制，通常在内核态和用户态间频繁切换。
     - 关系：实验帮助理解权限切换的基本过程，而OS原理中的多权限机制用于实现系统安全、稳定性和资源隔离。

#### 6. **控制状态寄存器（CSR）和中断向量**
   - **实验中的知识点**：
     - 实验通过`stvec`设置中断向量基地址，并使用`sepc`、`scause`等寄存器保存异常状态和中断的具体信息。CSR寄存器在实验中用于传递硬件中断和异常的状态。
     - 实验中通过读取和写入CSR寄存器来获取中断或异常的原因和返回地址。
   - **对应的OS原理**：
     - 在操作系统中，CSR是硬件和操作系统之间的接口。通过CSR，操作系统能够了解中断或异常的原因，并通过中断向量将控制权转移到对应的处理程序。
     - 中断向量表用于将不同的中断类型映射到不同的处理函数。
   - **含义与差异**：
     - 实验中通过设置`stvec`来实现简单的中断向量机制，操作系统的实现会处理更多种类的中断并动态调整中断处理程序的映射。
     - 关系：实验中的中断向量机制是操作系统中断处理流程的核心概念，在实际OS中，中断向量表的管理和使用更加灵活复杂。



### OS原理中很重要，但在实验中没有直接对应上的知识点：

#### **进程管理与调度**  

- 进程的创建、终止、状态转换
- 多任务调度算法（如轮转调度、优先级调度等）
- 进程的上下文切换与调度

#### **内存管理**  

- 虚拟内存机制
- 页面置换算法（如LRU、FIFO）
- 内存分配与释放（如动态内存分配、堆和栈管理）
- 地址空间的隔离和保护

#### **文件系统**  

- 文件系统的结构和管理
- 文件的创建、删除、读写、权限管理
- 数据块分配与回收

#### **设备管理与驱动程序**  

- I/O管理与设备驱动模型
- 阻塞与非阻塞I/O
- 硬件中断与DMA机制

**进程间通信（IPC）**  

- 共享内存、消息队列、信号、管道、套接字等IPC机制
- 同步与互斥机制（如信号量、锁、条件变量）

#### **死锁与进程同步**  

- 死锁的四个必要条件与死锁预防、避免、检测机制
- 信号量、互斥锁的使用与实现
- 生产者-消费者问题、读者-写者问题等经典同步问题

#### **系统调用接口**  

- 系统调用的实现机制
- 用户态与内核态的切换
- 系统调用的参数传递机制

#### **安全机制与权限管理**  

- 访问控制与权限模型
- 用户身份验证与权限分配
- 系统防护机制（如防止缓冲区溢出、漏洞攻击等）

这些知识点涉及到操作系统的广泛功能，在实验中可能由于聚焦于中断处理和异常机制，未涉及到上述主题。

